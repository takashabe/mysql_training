## 1. レプリケーションとは

1つのMySQLサーバ(マスター)のデータを、1つまたは複数のMySQLサーバ(スレーブ)に複製する機能。パフォーマンス向上やHA構成の構築など、幅広い用途に活用される。

### 1.1. レプリケーションのメリット

* パフォーマンス
  * マスターは更新専用(UPDATE, INSERT, DELETE等), スレーブは参照専用(SELECT)にすることで負荷が分散する
  * 一般的なWebアプリケーションでは読み取り負荷の方が多い傾向にあるため、レプリケーションでは参照性能向上の恩恵が大きい
* バックアップ
  * データはスレーブに複製され、スレーブはレプリケーションプロセスを一時停止できるため、スレーブで安全なコールドバックアップが取得可能
* 分析
  * マスターに負荷をかけずにスレーブの情報を分析可能
* ディザスタリカバリ
  * スレーブを遠方に配置することでディザスタリカバリの構築が可能

## 2. レプリケーションの仕組み

* マスター
  * Binlogダンプスレッド
    * バイナリログを生成
* スレーブ
  * スレーブI/Oスレッド
    * マスターに接続し、対象のバイナリログの更新を送信要求する
    * マスターのBinlogダンプスレッドから送信される更新を読み取り、リレーログとしてスレーブ側のローカルにコピーする
  * スレーブSQLスレッド: スレーブI/Oスレッドによって
    * スレーブI/Oスレッドによって書き込まれたリレーログを読み取り、SQLを実行する

## 3. レプリケーションの種類

* バイナリログの種類
  * ステートメントベースレプリケーション(SBR)
    * デフォルト
    * SQLをバイナリログに書き込む
    * ファイルサイズは小さい
    * 非決定性関数を使った場合にスレーブで不整合が生じる可能性がある
      * UUID(), RAND()など
      * `UPDATE foo SET id = UUID()...` のようなクエリがそのまま転送されるため
  * 行ベースレプリケーション(RBR)
    * 更新結果をバイナリログに書き込む
    * ファイルサイズは大きい
  * 混合(Mixed)
    * 通常時はSBRで書き込み
    * 関数にUUID()が含まれる、FOUND_ROWS()などが含まれるときはRBRに切り替わる
* レプリケーション同期の種類
  * 非同期レプリケーション
    * デフォルト
    * マスター側でトランザクションが終了したら非同期にスレーブに送信する
    * マスターで障害が発生した場合、障害発生直前のトランザクションがスレーブに送信されていない可能性がある
  * 準同期レプリケーション
    * マスター側でコミット後、トランザクションはブロックされ、少なくとも1つのスレーブがリレーログを書き込んだタイミングでマスターに通知、トランザクションが完了する
    * 複数のスレーブが存在する場合、いずれか1つのスレーブから応答が返った時点で完了と見なす
      * 一部のスレーブに障害が起こっていてもレプリケーション自体への支障はない
    * スレーブからの受信通知がタイムアウトした場合は非同期レプリケーションになる
      * その後受信通知が届いた段階で準同期レプリケーションに戻る

## 4. レプリケーションの設定

レプリケーションの設定方法はいくつかあります。ここでは代表的なもの3つを紹介します。

### 4.1. マスターからmysqldumpでデータをコピーする

スレーブがまだ存在せず、マスターにデータが存在する場合はmysqldumpを用いてスレーブをセットアップ出来ます。
マスターを止めずにスレーブをセットアップすることが出来ますが、データ量が多い場合は現実的ではありません。

#### 4.1.1. マスター上で設定ファイルの編集を行う

```
[mysqld]
# 各MySQLサーバを識別するためのIDの設定
# レプリケーションクラスタ内で一意である必要がある
server-id=1

# バイナリログの有効化
# ログファイル名のprefixを `mysql_bin` として設定する場合の例
# prefixを省略した場合はホスト名が使われ、仮にホスト名が変更された場合に一貫性を保つのが面倒になるため、何か設定することを推奨
log_bin=mysql_bin

# バイナリログをコミットと同時にディスクに書き込む
# マスターをクラッシュセーフにするために必要
innodb_flush_log_at_trx_commit=1
sync_binlog=1

# リレーログをテーブル(mysql.slave_relay_log_info)に書き込む
# スレーブをクラッシュセーフにするために必要
relay_log_info_repository=TABLE
relay_log_recovery=ON
```

※ 設定ファイルを編集後、mysqlを再起動する

#### 4.1.2. マスターでレプリケーション用ユーザの作成

```
# スレーブがlocalhostにいる前提
mysql> CREATE USER 'repl'@'localhost' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'localhost';
```

#### 4.1.3. マスターのデータをダンプ

```
# single-transactionオプションを指定することでロックをかけずにmysqldumpが実行可能
$ mysqldump --all-databases --master-data --single-transaction --flush-logs > ~/master_dump.db
```

#### 4.1.4. スレーブ上で設定ファイルを編集する

```
[mysqld]
# 各MySQLサーバを識別するためのIDの設定
# レプリケーションクラスタ内で一意である必要がある
server-id=2

# 更新を禁止する
read-only
```

※ 設定ファイルを編集後、mysqlを再起動する

#### 4.1.5. マスターで取得したダンプをスレーブへリストアする

```
$ mysql -uroot < ~/master_dump.db
```

#### 4.1.6. レプリケーションの設定

ダンプファイルの先頭にマスターのバイナリログファイル名と開始位置があるので確認する

```
$ head -n 100 ~/master_dump.db | grep 'CHANGE MASTER TO'
```

マスターの構成情報をスレーブに設定する

```
# 1つ前で確認したログファイル名、開始位置をそれぞれ MASTER_LOG_FILE, MASTER_LOG_POS に指定する
mysql> CHANGE MASTER TO
    ->   MASTER_HOST='localhost',
    ->   MASTER_USER='repl',
    ->   MASTER_PORT=3306,
    ->   MASTER_PASSWORD='password',
    ->   MASTER_LOG_FILE='foo',
    ->   MASTER_LOG_POS=bar;
```

#### 4.1.6. レプリケーションの開始

```
mysql> START SLAVE;
```

なお、設定変更などのためにレプリケーションを初期化したい場合は下記を実行する

```
mysql> RESET MASTER; # マスターバイナリログの受信を止める
mysql> RESET SLAVE;  # リレーログの初期化
```

一時的にレプリケーションを停止したい場合は以下を実行する

```
mysql> STOP SLAVE;
```

### 4.2. 既存のスレーブからデータをコピーする

#### 4.2.1. マスター上にレプリケーション用ユーザを作成する(内容はマスターから作成する場合と同様)

#### 4.2.2. 新しいスレーブで設定ファイルを作成する

既存のスレーブから設定ファイルをコピーし、server_idオプションを書き換える。
report_hostオプションが設定されている場合、またはディレクトリのレイアウトが異なる場合は適宜オプションを書き換える必要がある。

#### 4.2.3. 既存のスレーブを1台停止する

```
$ sudo service mysqld stop
```

#### 4.2.4. 既存のスレーブから新しいスレーブへデータをコピーする

データディレクトリ( `/var/lib/mysql/` )を `scp` や `ftp` で新しいスレーブ上にコピーする

#### 4.2.5. 既存のスレーブおよび新しいスレーブでmysqlを起動する

### 4.3. ストレージのスナップショットをコピーする

LVMやZFSなど、スナップショット機能が実装されたストレージエンジンを使っている場合に可能な手法です。
大抵スナップショットは瞬時に実行されるので、マスターを止めずに素早いセットアップの要求に答えることが可能です。
具体的な手順はストレージに依存するので省略しますが、InnoDBの場合概ね以下の手順でセットアップが可能です。

#### 4.3.1. マスター上で設定ファイルを用意する

#### 4.3.2. マスター上にレプリケーション用ユーザを作成する

#### 4.3.3. スナップショットを取得する

#### 4.3.4. スナップショットボリュームからデータディレクトリをスレーブにコピーする

#### 4.3.5. スレーブを起動する

#### 4.3.6. スレーブ上でレプリケーションを設定する

#### 4.3.7. レプリケーションを開始する

### 4.4. トラブルシューティング

レプリケーションが設定出来ない場合、以下のドキュメントが役に立ちます。

[レプリケーションのトラブルシューティング](https://dev.mysql.com/doc/refman/5.6/ja/replication-problems.html)

### 4.5. 動作確認

#### 4.5.1. マスター側での確認

```
# Commandフィールドに Binlog Dump がある
mysql> SHOW PROCESSLIST\G

# スレーブサーバの情報が出力される
mysql> SHOW SLAVE HOSTS;
```

#### 4.5.2. スレーブ側での確認

```
mysql> SHOW SLAVE STATUS\G
```

`SHOW SLAVE STATUS` で見るべき項目

| 項目 | 内容 |
|------|------|
| Slave_IO_State | スレーブの現在のステータス<br />詳しくは https://dev.mysql.com/doc/refman/5.6/ja/slave-io-thread-states.html |
| Slave_IO_Running | スレーブI/Oスレッドが実行中かどうか |
| Slave_SQL_Running | スレーブSQLスレッドが実行中かどうか |
| Last_IO_Error | リレーログを処理するときにI/Oスレッドによって登録された最後のエラー |
| Last_SQL_Error | リレーログを処理するときにSQLスレッドによって登録された最後のエラー |
| Seconds_Behind_Master | スレーブSQLスレッドがマスターバイナリログの処理より何秒遅れているか |
| Read_Master_Log_Pos | スレーブ I/O スレッドがマスターバイナリログ(Master_Log_file)からどのくらい離れてイベントを読み取ったかを示す、ログ内の座標 |
| Exec_Master_Log_Pos | スレーブ SQL スレッドがマスターバイナリログ(Relay_Master_Log_File)から受け取ったイベントをどのくらい離れて実行したかを示す、ログ内の座標 |
| Relay_Log_Pos | スレーブ SQL スレッドがスレーブリレーログ(Relay_Log_File)をどのくらい離れて実行したかを示す、リレーログ内の座標 |

リレーログテーブルの確認

```
mysql> SELECT * FROM mysql.slave_relay_log_info;
```

### 演習

* `4.1. マスターからmysqldumpでデータをコピーする` をベースにしてレプリケーションをセットアップしてみましょう
* mysqldump後、スレーブを開始する前にマスターにデータを挿入し、スレーブ開始後にデータが同期されていることを確認しましょう

#### mysqld_multi補足

* 全サーバ起動: `mysqld_multi start`
* 全サーバ停止: `mysqld_multi stop`
* サーバ1のみ停止: `mysqld_multi stop 1`
* サーバ1のみ起動: `mysqld_multi start 1`
* サーバ稼動状態の確認: `mysqld_multi report`
* 設定ファイル: [mysqld1], [mysqld2] にそれぞれのサーバ固有の設定を書きます

## 5. レプリケーション障害

何かしらの原因によりレプリケーションが停止することがあります。
ここでは大きく以下のカテゴリに分けて対応方法を紹介します。

* SQLスレッドの停止
* IOスレッドの停止

### 5.1. SQLスレッドの停止

SQLスレッドの停止は `SHOW SLAVE STATUS` の結果で `Slave_SQL_Running: No` になっていることで確認出来ます。

* 原因
  * メモリ不足
    * 各種バッファに割り当てるメモリが不足している
    * 一時的なメモリ不足の場合には、単純にSQLスレッドの再開で復旧される
    * 恒久的な対応にはスケールアップが必要となる場合がある
  * スレーブ上で更新を走らせてしまう
    * マスターとスレーブ上でデータが食い違ってしまうことによるエラーが発生する可能性がある
      * 重複キーエラーなど
    * 更新内容が把握出来ており、量がわずかであれば手動で再度更新して復旧が可能
      * 手動更新後、エラーが発生し続けている場合、それが無視出来るエラーであると分かっていれば `SET GLOBAL SQL_SLAVE_SKIP_COUNTER = N(スキップするエラーイベント数);` でレプリケーションを再開することが可能
    * 多くの場合はスレーブを再セットアップするのが良い
    * スレーブ上で `read-only` オプションを設定することでroot以外は更新不可になるため問題が生じにくくなる
  * バイナリログの欠損
    * マスターがクラッシュするなど、バイナリログが欠損してしまう可能性がある
    * デフォルトではバイナリログは同期的に書き込まないため、スレーブとのデータ不整合が生じる可能性がある
    * スレーブを再セットアップする以外の選択肢はない
    * `sync_binlog=1` を設定しておくことでバイナリログを同期的に書き込めるため回避出来る

### 5.2. IOスレッドの停止

IOスレッドの停止は `SHOW SLAVE STATUS` の結果で `Slave_IO_Running: No` になっていることで確認出来ます。

* 原因
  * ネットワークエラー
    * ファイアウォールなどにより通信が出来ない可能性がある
    * ネットワークエラー解消後はレプリケーションを再開することで復旧が可能
  * レプリケーション用ユーザがマスターにログイン出来ない
    * スレーブが新しいホストである場合など、マスター側で権限が付与されていない場合に起こりうる
    * 正しく権限が設定された後、レプリケーションを再開することで復旧が可能
  * イベントが転送出来ない
    * mysqlとクライアント(スレーブ)間でやり取り可能な最大メッセージサイズ `max_allowed_packet` の上限を超えた
    * BLOB型や長大なTEXT型のデータが原因で発生する可能性が高い
    * `SHOW SLAVE STATUS` の `Last_IO_Error: Packet too large` が記録される
    * `max_allowed_packet` を再設定後、レプリケーションの再開で復旧が可能

### 演習

* `5.1. SQLスレッドの停止` - `スレーブ上で更新を走らせてしまう` をベースにして実際にスレーブ上で更新を行い、復旧させてみましょう
* レプリケーションを壊した後に、レプリケーションが正常に稼働していてデータ不整合が無い状態になっていればOKです

## 6. スレーブ昇格

マスターがクラッシュしたなどの場合にスレーブをマスターに昇格する方法です。

### 6.1. スレーブが1台の場合

#### 6.1.1. レプリケーションを停止する

```
# スレーブIOスレッドの停止
mysql> STOP SLAVE IO_THREAD;

# `Has read all relay log` というログが出るまで待つ
mysql> SHOW PROCESSLIST\G

# レプリケーションを完全に停止する
mysql> STOP SLAVE;
```

#### 6.1.2. マスター用の設定を投入する

`my.cnf` の設定、レプリケーション用ユーザの作成などを行います。手順は通常時のマスターセットアップ時と同様です。
設定を変更した後にmysqlを再起動することを忘れずに。

#### 6.1.3. 新スレーブをセットアップする

通常のスレーブセットアップ時と同様です。

#### 6.1.4. アプリケーションからの接続先を変更する

IPアドレスや接続先ポートが変更になった場合はその対応を行う。

### 6.2. スレーブが複数台の場合

#### 6.2.1. マスターに昇格するスレーブを決定する

クラッシュのタイミングによってはスレーブ間でデータ差異が発生している可能性があります。
そのため、最も進んでいるスレーブを調べ、マスター昇格候補とする必要があります。

```
# 各スレーブで実施し、 `MASTER_LOG_FILE` および `Read_Master_Log_Pos` が最も進んでいるスレーブを探す
mysql> SHOW SLAVE STATUS\G
```

#### 6.2.2. 最も進んでいるスレーブをマスターに昇格する

スレーブが1台の場合同様、スレーブをマスターにセットアップします

#### 6.2.3. 他スレーブの設定を変更し、新マスターを見るようにする

この時点で致命的なデータのズレが発生していなければ以下で新マスターを見るようにすればレプリケーションが再開されます。

```
# パラメータは適宜読み替えてください
mysql> CHANGE MASTER TO
    ->   MASTER_HOST='localhost',
    ->   MASTER_USER='repl',
    ->   MASTER_PORT=3306,
    ->   MASTER_PASSWORD='password',
    ->   MASTER_LOG_FILE='foo',
    ->   MASTER_LOG_POS=bar;
```

### 演習

* `6.1. スレーブが1台の場合` をベースにしてマスタースレーブの入れ替えを行ってみましょう
* mysqldump後、新スレーブを開始する前に新マスターにデータを挿入し、スレーブ開始後にデータが同期されていることを確認しましょう
  * マスターをスレーブに降格する場合、 `RESET MASTER` , `RESET SLAVE` を用いてレプリケーション情報の消去を行ってから再構築するのが確実です

## 7. Global Transaction ID(GTID)

既存の仕組みではレプリケーションを開始する際にバイナリログのファイル名と開始位置を調べる必要があります。そこでポジションの指定を自動化して運用を楽にするための仕組みがGTIDです。

### 7.1. GTIDとは

* レプリケーション全体で個々のトランザクションに付与されるユニークなID
* UUIDとトランザクションの組を元にしたIDが生成され、バイナリログに記録される
* マスター接続時にバイナリログをスキャンして開始位置を動的に決定する

### 7.2. GTIDを有効にしたレプリケーションのセットアップ

#### 7.2.1. GTID用の設定を追加

```
# マスター、スレーブ共に以下の設定が必要
gtid-mode=on
enforce-gtid-consistency=1
log-slave-updates=1
```

#### 7.2.2. マスターでレプリケーション用ユーザの作成

手順は非GTID環境と同様

```
# 例
mysql> CREATE USER 'repl'@'localhost' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'localhost';
```

#### 7.2.3. マスターのデータをダンプ

手順は非GTID環境と同様
※ もしコールドバックアップでデータディレクトリをコピーする方法を取る場合は `auto.cnf` を事前に削除しておく必要がある。UUIDの生成は `auto.cnf` が存在すればそれを元にしてしまうため、UUIDの重複が起きてしまう

```
$ mysqldump --all-databases --master-data --single-transaction --flush-logs > ~/gtid_master_dump.db
```

#### 7.2.4. マスターで取得したダンプをスレーブへリストアする

```
$ mysql -uroot < ~/master_dump.db
```

#### 7.2.5. スレーブでレプリケーションのセットアップをする

```
mysql> CHANGE MASTER TO
    ->   MASTER_HOST='localhost',
    ->   MASTER_USER='repl',
    ->   MASTER_PORT=3306,
    ->   MASTER_PASSWORD='password',
    ->   MASTER_AUTO_POSITION=1;
```

#### 7.2.6. スレーブでレプリケーションを開始

```
mysql> START SLAVE;
```

### 7.3. GTIDの注意点

* マスター接続時にバイナリログをスキャンするので、ファイルサイズは大きくし過ぎないほうが良い
  * max_binlog_size
* レプリケーションフィルタリングを使うとGTIDに欠番が出来てしまうので、フィルタリングは併用しない
* スレーブでバイナリログを吐く必要があるため、 `log_slave_updates` が必須

### 演習

* `7.2. GTIDを有効にしたレプリケーションのセットアップ` をベースにしてGTIDでのレプリケーションをセットアップしてみましょう
* mysqldump後、スレーブを開始する前にマスターにデータを挿入し、スレーブ開始後にデータが同期されていることを確認しましょう


## 8. Tips

### 8.1. 遅延レプリケーション

* スレーブ側で意図的に任意時間レプリケーションを遅延させる
* レプリケーション遅延が発生した場合のアプリケーション挙動の確認、または常に遅延させておきバックアップをリストアせずに以前の状態の調査などに利用される
* `CHANGE MASTER TO MASTER_DELAY = N;` を実行することでN秒遅延させることが出来る

### 8.2. レプリケーションフィルタリング

* 任意のスレーブに特定のテーブルのみをレプリケーションさせる
* レプリケーションされる情報が多すぎる影響で遅延が起こってしまう場合など、転送されるデータを絞ることが有効なケースがある
* データベース `foo` のみをレプリケーション対象にしたい場合は `--replicate-wild-do-table=foo.%` を設定ファイルに追加することでフィルタリングが可能になる

### 8.3. mysqlfailover

* MHAなどのサードパーティツールで実現していたHA構成を公式のツールセットで実現可能になる
* 内部でGTIDを利用しているため、GTIDを有効にしていることが前提
* MySQL Workbenchに含まれる `mysql-utilities` ツールセット内の `mysqlfailover` を利用する
* mysqlfailoverを起動しておくだけで、マスターがクラッシュした時点で自動的にフェイルオーバーが行われる
  * `mysqlfailover --master=root@192.168.195.144:3306 --slaves=root@192.168.195.145:3306 --log=/tmp/failover.log`
* マスター、スレーブで `report_host` の設定が必要

## 参考リンク

* [MySQL 5.6 リファレンスマニュアル](https://dev.mysql.com/doc/refman/5.6/ja/)
* [MySQL 5.6 リファレンスマニュアル :: 17 レプリケーション](https://dev.mysql.com/doc/refman/5.6/ja/replication.html)
