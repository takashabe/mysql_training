## 1. パフォーマンス観点

単純にパフォーマンスと言った場合の捉え方は人様々である。
例えば以下のような項目が考えられる。

* 1秒あたりのクエリ数
* CPU使用率
* スケーラビリティ

前提としてここではパフォーマンスは `1クエリあたりの応答時間` を指標とする。
データベースサーバとして最も興味があるであろう、クエリを解釈してデータを返すというタスクのパフォーマンスを見るのに適当だからである。

また特に断りのない限り、本内容はInnoDBを想定したものとする。

* todo: どこかでチューニングの手順を書きたい
  * 1. スロークエリログで統計情報を収集
  * 2. explainで解析
  * 3. インデックス貼る、クエリ書き換える。→1に戻る

## 2. 計測

何をチューニングすべきか、チューニングした結果どう変わったか、その指標を計測出来るようにしておく。

### 2.1. スロークエリログ

クエリにどのくらい時間がかかったかなどの情報を出力するためのログ。後述するプロファイリングツールはこのログを解析して結果を出しているものが多い。

#### 主要な設定項目

* `slow_query_log`
  * スロークエリログを出力するかどうか
* `long_query_time`
  * スロークエリログに出力するための閾値とする実行時間
  * 0 を設定することで全クエリが出力される
  * 0.5秒以上かかったクエリを出力したいのであれば `0.5` と指定する
* `log_queries_not_using_indexes`
  * インデックスが使われていないクエリを出力するかどうか
  * 有効化すると `long_query_time` に該当しないクエリでも出力されるようになる
* `slow_query_log_file`
  * スロークエリログの出力先
  * デフォルトでは `datadir/<hostname>-slow.log` に出力される
* `log_slow_admin_statements`
  * 管理ステートメントのログ出力を行うかどうか
  * 対象のステートメント
    * ALTER TABLE
    * ANALYZE TABLE
    * CHECK TABLE
    * CREATE INDEX
    * DROP INDEX
    * OPTIMIZE TABLE
    * REPAIR TABLE

#### 設定ファイルサンプル

```
# スロークエリログを出力する
slow_query_log=1

# ログを出す閾値を1秒にする
# ※ 1秒未満のクエリが大量にあり、それで全体的に遅くなっている場合には対応出来ない。その場合はmysqlコンソールから閾値を一時的に0にするなどして対応する
long_query_time=1

# インデックスが使われていないクエリは特別出力しない
log_queries_not_using_indexes=0

# ログファイルは `/var/log/` に集めておく
slow_query_log_file=/var/log/mysql/slow.log

# 管理ステートメントは出力しない
# 管理ステートメントは多くの場合人間が主体となって行うので無視しておく
log_slow_admin_statements=0
```

### 2.2. スロークエリログの解析

スロークエリログ単体ではログの量が膨大になるため、通常ログと合わせて解析ツールが用いられる。

#### mysqldumpslow

* 特徴
  * 公式の解析ツール
  * mysqlに付属している
  * 以下いずれかの項目でソートした結果を出力出来る
    * 総ロックタイム
    * 総行数
    * 総実行時間
    * 総クエリ数
    * 平均ロックタイム
    * 平均行数
    * 平均実行時間(デフォルト)

実行例

```
# 総実行時間が長い順でソート
$ mysqldumpslow -s t slow_query.log
```

#### pt-query-digest

* 特徴
  * Percona Serverを作っているPercona社が作っている
  * スロークエリログ以外にも `PROCESSLIST` や `tcpdump` のデータを元に解析が可能
  * 総実行時間、総クエリ数などいくつかの軸でクエリをランキングしてくれる
  * 解析と同時に各クエリのサマリの `explain` 結果が出力可能

* インストール

RHEL系

```
yum install perl-Time-HiRes perl-IO-Socket-SSL
yum localinstall http://www.percona.com/redir/downloads/percona-toolkit/LATEST/RPM/percona-toolkit-2.2.7-1.noarch.rpm
```

実行例

```
# スロークエリログから読む
$ pt-query-digest --type slowlog slow.log

# processlistから読む
$ pt-query-digest --processlist h=localhost,u=root,p=password --run-time 60

# tcpdumpから読む
$ tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 mysql.tcpdump
$ pt-query-digest --type tcpdump mysql.tcpdump
```

* todo: どういう観点で見ていくかを書く
  * まず総実行時間を見て、総クエリ数、ロック数を見ていくなど

## 3. インデックス

* 前提はInnoDBとする
  * インデックスはB+Tree構造を使っているものとする
* どういう場合に有効か
  * 多くの場合で有効。とりあえずやっていない場合はやって良い
  * インデックスを貼っても検索行数が大きすぎる場合は効果が薄い
    * パーティション、シャーディングでテーブルを分割させて母数のデータ数を減らす
    * 巨大なユーザテーブルを分解して、特定のグループだけが集まるようなユーザテーブルを抽出するなど
(* インデックスの構造
  * インデックスの持ち方
  * クラスタインデックス
  * セカンダリインデックス)
* カーディナリティ
* 複合インデックスの順番
  * カーディナリティも考慮して最初からとか
( * 実際にインデックスを使うときのコーナーケース
  * プレフィックスインデックス
    * BLOB型やTEXT型などの非常に大きいデータを持つカラムにインデックスを貼りたい場合
    * InnoDBはインデックスをキーとするので余計にディスクを食う。そもそも付けれるインデックス名に制限長がある)
* explain
* インデックスを使うためのクエリの書き方
  * 範囲指定とか
  * 順序の話
  * 最終手段としてforce index
* 講師側で準備したindexチューニング前後のexplain結果(サンプルファイル)を見せる

インデックスはデータファイル上の特定行におけるポインタの様なものである。もしインデックスが無ければ、クエリで該当行を見つけるためにデータファイルを先頭行から始めてテーブル全体を読み取る必要がある。

#### インデックスの構造

* Bツリー
  * InnoDBのインデックスはBツリーで管理される
  * 検索時の計算量が小さくなるような構造
  * ノード1つにつきブロック1つと紐付けられる
    * HDDはブロック間のシーク時間がボトルネックとなるので特に有効
    * SSDも結局ブロックデバイスなので依然重要
* クラスタインデックス
  * 全てのテーブルに必ず存在する特別なインデックス
  * ノードのキーは以下のいずれかになる。ほとんどの場合は主キーが選択される
    * 1. 主キー
    * 2. NOT NULLかつUNIQUEなカラム
    * 1, 2に該当しない場合、暗黙的に行IDが振られたキーが生成され利用される
  * リーフノードにはレコードのデータ全てが保存される
    * データ自体がノードに格納されるため、検索とデータのフェッチが同時に行われる
* セカンダリインデックス
  * `create index` 文で作られるいわゆるインデックス
  * ノードのキーにはインデックス名がそのまま利用される
  * リーフノードにはクラスタインデックスのキーが格納される
    * つまりデータを取るためにはセカンダリインデックス→クラスタインデックスのアクセスが必要となる
    * ただし必要なデータがセカンダリインデックスのキーで事足りていればクラスタインデックスへのアクセスは不要となる
      * カバリングインデックスと呼ばれる

#### インデックス利用の仕方

* カーディナリティ
  * 全レコードに対して、インデックスを使用して絞り込める件数の割合
  * 絞り込める件数が少ないほどカーディナリティが高い状態である
  * 例
    * カーディナリティが高い
      * 住所、電話番号、更新日時
    * カーディナリティが低い
      * 性別、フラグ、都道府県

確認の仕方

```
mysql> SHOW INDEX FROM user;
```

* 複合インデックス
  * 複数のカラムを含んだインデックスが複合インデックスである
  * MySQLでは原則1クエリで使用出来るインデックスは1つだけである
  * 1インデックスとはindex key単位となる
    * 例えば以下のインデックスはそれぞれ1つと数えられる
      * A. `CREATE INDEX idx_user_id ON user(user_id);`
      * B. `CREATE INDEX idx_job_id ON user(job_id);`
      * C. `CREATE INDEX idx_user_id_and_job_id ON user(user_id, job_id);`
  * MySQLは1インデックスごとにインデックスツリーを構築する
    * 1クエリで使用するインデックスは1つに限定される
  * WHEREやORDER BYなどで複数のカラムを検索対象とする場合、複合インデックスを使う必要がある

設定の仕方

```
mysql> CREATE INDEX idx_user_id_and_job_id ON user(user_id, job_id);
```

#### インデックス利用の調査

* EXPLAIN
  * 任意のクエリに対するMySQLの実行計画(使用されるインデックス、ファイルソートの有無など)を調べることが出来る
  * MySQL5.6以前はSELECTにのみ対応していた。5.6以降はINSERTやUPDATEでもEXPLAINにかけられるようになっている(もちろん実行はされない)

実行例

```
mysql> EXPLAIN SELECT * FROM follow WHERE user_id = 100 ORDER BY created_at DESC;
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra                       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
|  1 | SIMPLE      | follow | ref  | PRIMARY       | PRIMARY | 4       | const |  623 | Using where; Using filesort |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
```

EXPLAIN結果は状況により多岐に渡るため、ここでは特に重要なポイントについて記載する

| 項目 | 意味 |
| ---- | ---- |
| select_type | JOIN, サブクエリを使用した時、どのテーブルにどういう順番でクエリが実行されるかを示す。tableカラムと合わせて見る。単一テーブルしか使わない場合は気にする必要はない |
| type | 対象テーブルに対してどのようにアクセスしたかを示す。特に注意すべきは以下の2つ<br /> index: フルインデックススキャン。インデックス全体をスキャンしているため遅い<br /> ALL: フルテーブルスキャン。インデックスが使用されていない状態 |
| key | どのインデックスが使用されたかを示す |
| rows | 対象テーブルからフェッチする行数の目安。インデックスが適切に使われいてもrowsが多すぎる場合、結果的に遅いクエリとなってしまう可能性がある。そのような場合はテーブル分割などを検討する |
| Extra | クエリ結果のソートが行われたか、実行にテンポラリテーブルが必要かどうかなど…様々な追加情報が出力される。以下によく問題になるであろう出力の一例を示す<br /> Using filesort: ORDER BY句などでクエリ結果をソートする必要がある場合に出力される。必要なソートがインデックスで行われていれば解決出来る<br /> Using tenporary: JOINの結果をソートする場合など、クエリ実行にテンポラリテーブルが必要となる場合に出力される。WHEREの検索条件とソート対象のカラムを1つのテーブルに集中させるなどで解決出来る |

* 注意点
  * 正確な実行計画を得るためにはプロダクションで使われている実際のデータで行う必要がある
  * テーブルの行数やインデックスの分散の仕方によって実行計画が変わる可能性があるからである

#### インデックスを使うためのクエリ

* 範囲指定
* 順序
* force index(最終手段)

#### インデックス設定前後のサンプル

## 4. パーティション

* 母数を減らすために有効
* 設定方法

## 5. シャーディング

* 母数を減らすために有効
* Updateの負荷が分散出来る
* 設定方法
  * キーの振り分け方式など
    * ユーザID % 100 が計算しやすくて運用にも便利だよという結論

## 6. サーバ設定

* メモリに載せたほうが良い

## 7. Tips

* パフォーマンス上げるための考え方
  * インデックス, クエリ
  * ハードウェア
  * 最後の手段としてパーティション、シャーディングとか

## 参考メモ

http://naokirin.hatenablog.com/entry/2015/02/07/193609
http://www.mysql.gr.jp/frame/modules/bwiki/index.php?plugin=attach&refer=matsunobu&openfile=Session-Index.pdf
