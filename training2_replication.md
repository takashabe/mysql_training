## 1. はじめに

この文章で対象にする事柄、および全体的な考え方について述べる。
また特に断りのない限り、本内容はMySQL5.5以降 InnoDBを想定したものとする。

#### パフォーマンスの定義

単純にパフォーマンスと言った場合の捉え方は人様々である。
例えば以下のような項目が考えられる。

* 1秒あたりのクエリ数
* CPU使用率
* スケーラビリティ

前提としてここではパフォーマンスは `1クエリあたりの応答時間` を指標とする。
データベースサーバとして最も興味があるであろう、クエリを解釈してデータを返すというタスクのパフォーマンスを見るのに適当だからである。


#### 最適化の考え方

MySQLに限らず原則通り `計測` 、 `最適化` のループを回してくことになる。断片的な情報だけに頼って場当たり的な最適化を行うのは避けたほうが良い。

MySQLにおいては主に以下の様な手法を使って最適化を進めると良い

1. クエリの観測(スロークエリログの出力)
2. ボトルネックを見つける(スロークエリログの解析)
3. ボトルネックとなっているクエリの解析(EXPLAIN)
4. インデックスの作成、クエリの書き換えを試す

※以後再度クエリの観測から始める

またデータサイズやトラフィックが膨大になってきた、もしくは事前に分かっている場合は性能の良いハードウェアを用意する、またはパーティション、シャーディングを検討すると良いだろう。

## 2. 計測

何を最適化すべきか、最適化した結果どう変わったか、その指標を計測出来るようにしておく。

### 2.1. スロークエリログ

クエリにどのくらい時間がかかったかなどの情報を出力するためのログ。後述するプロファイリングツールはこのログを解析して結果を出しているものが多い。

#### 主要な設定項目

* `slow_query_log`
  * スロークエリログを出力するかどうか
* `long_query_time`
  * スロークエリログに出力するための閾値とする実行時間
  * 0 を設定することで全クエリが出力される
  * 0.5秒以上かかったクエリを出力したいのであれば `0.5` と指定する
* `log_queries_not_using_indexes`
  * インデックスが使われていないクエリを出力するかどうか
  * 有効化すると `long_query_time` に該当しないクエリでも出力されるようになる
* `slow_query_log_file`
  * スロークエリログの出力先
  * デフォルトでは `datadir/<hostname>-slow.log` に出力される
* `log_slow_admin_statements`
  * 管理ステートメントのログ出力を行うかどうか
  * 対象のステートメント
    * ALTER TABLE
    * ANALYZE TABLE
    * CHECK TABLE
    * CREATE INDEX
    * DROP INDEX
    * OPTIMIZE TABLE
    * REPAIR TABLE

#### 設定ファイルサンプル

```
# スロークエリログを出力する
slow_query_log=1

# ログを出す閾値を1秒にする
# ※ 1秒未満のクエリが大量にあり、それで全体的に遅くなっている場合には対応出来ない。その場合はmysqlコンソールから閾値を一時的に0にするなどして対応する
long_query_time=1

# インデックスが使われていないクエリは特別出力しない
log_queries_not_using_indexes=0

# ログファイルは `/var/log/` に集めておく
slow_query_log_file=/var/log/mysql/slow.log

# 管理ステートメントは出力しない
# 管理ステートメントは多くの場合人間が主体となって行うので無視しておく
log_slow_admin_statements=0
```

### 2.2. スロークエリログの解析

スロークエリログ単体ではログの量が膨大になるため、通常ログと合わせて解析ツールが用いられる。

いずれのツールを場合もボトルネックを見つけるためのアプローチとして、総実行時間を見ていくのが良いだろう。

#### mysqldumpslow

* 特徴
  * 公式の解析ツール
  * mysqlに付属している
  * 以下いずれかの項目でソートした結果を出力出来る
    * 総ロックタイム
    * 総行数
    * 総実行時間
    * 総クエリ数
    * 平均ロックタイム
    * 平均行数
    * 平均実行時間(デフォルト)

実行例

```
# 総実行時間が長い順でソート
$ mysqldumpslow -s t slow_query.log
```

#### pt-query-digest

* 特徴
  * Percona Serverを作っているPercona社が作っている
  * スロークエリログ以外にも `PROCESSLIST` や `tcpdump` のデータを元に解析が可能
  * 総実行時間、総クエリ数などいくつかの軸でクエリをランキングしてくれる
  * 解析と同時に各クエリのサマリの `explain` 結果が出力可能

* インストール

RHEL系

```
yum install perl-Time-HiRes perl-IO-Socket-SSL
yum localinstall http://www.percona.com/redir/downloads/percona-toolkit/LATEST/RPM/percona-toolkit-2.2.7-1.noarch.rpm
```

実行例

```
# スロークエリログから読む
$ pt-query-digest --type slowlog slow.log

# processlistから読む
$ pt-query-digest --processlist h=localhost,u=root,p=password --run-time 60

# tcpdumpから読む
$ tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 mysql.tcpdump
$ pt-query-digest --type tcpdump mysql.tcpdump
```

## 3. インデックス

インデックスはデータファイル上の特定行におけるポインタの様なものである。もしインデックスが無ければ、クエリで該当行を見つけるためにデータファイルを先頭行から始めてテーブル全体を読み取る必要がある。

#### インデックスの構造

* Bツリー
  * InnoDBのインデックスはBツリーで管理される
  * 検索時の計算量が小さくなるような構造
  * ノード1つにつきブロック1つと紐付けられる
    * HDDはブロック間のシーク時間がボトルネックとなるので特に有効
    * SSDも結局ブロックデバイスなので依然重要
* クラスタインデックス
  * 全てのテーブルに必ず存在する特別なインデックス
  * ノードのキーは以下のいずれかになる。ほとんどの場合は主キーが選択される
    * 1. 主キー
    * 2. NOT NULLかつUNIQUEなカラム
    * 1, 2に該当しない場合、暗黙的に行IDが振られたキーが生成され利用される
  * リーフノードにはレコードのデータ全てが保存される
    * データ自体がノードに格納されるため、検索とデータのフェッチが同時に行われる
* セカンダリインデックス
  * `create index` 文で作られるいわゆるインデックス
  * ノードのキーにはインデックス名がそのまま利用される
  * リーフノードにはクラスタインデックスのキーが格納される
    * つまりデータを取るためにはセカンダリインデックス→クラスタインデックスのアクセスが必要となる
    * ただし必要なデータがセカンダリインデックスのキーで事足りていればクラスタインデックスへのアクセスは不要となる
      * カバリングインデックスと呼ばれる

#### インデックス利用の仕方

* カーディナリティ
  * 全レコードに対して、インデックスを使用して絞り込める件数の割合
  * 絞り込める件数が少ないほどカーディナリティが高い状態である
  * 例
    * カーディナリティが高い
      * 住所、電話番号、更新日時
    * カーディナリティが低い
      * 性別、フラグ、都道府県

確認の仕方

```
mysql> SHOW INDEX FROM user;
```

* 複合インデックス
  * 複数のカラムを含んだインデックスが複合インデックスである
  * MySQLでは原則1クエリで使用出来るインデックスは1つだけである
  * 1インデックスとはindex key単位となる
    * 例えば以下のインデックスはそれぞれ1つと数えられる
      * A. `CREATE INDEX idx_user_id ON user(user_id);`
      * B. `CREATE INDEX idx_job_id ON user(job_id);`
      * C. `CREATE INDEX idx_user_id_and_job_id ON user(user_id, job_id);`
  * MySQLは1インデックスごとにインデックスツリーを構築する
    * 1クエリで使用するインデックスは1つに限定される
  * WHEREやORDER BYなどで複数のカラムを検索対象とする場合、複合インデックスを使う必要がある

設定の仕方

```
mysql> CREATE INDEX idx_user_id_and_job_id ON user(user_id, job_id);
```

#### インデックス利用の調査

* EXPLAIN
  * 任意のクエリに対するMySQLの実行計画(使用されるインデックス、ファイルソートの有無など)を調べることが出来る
  * MySQL5.6以前はSELECTにのみ対応していた。5.6以降はINSERTやUPDATEでもEXPLAINにかけられるようになっている(もちろん実行はされない)

実行例

```
mysql> EXPLAIN SELECT * FROM follow WHERE user_id = 100 ORDER BY created_at DESC;
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra                       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
|  1 | SIMPLE      | follow | ref  | PRIMARY       | PRIMARY | 4       | const |  623 | Using where; Using filesort |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
```

EXPLAIN結果は状況により多岐に渡るため、ここでは特に重要なポイントについて記載する

| 項目 | 意味 |
| ---- | ---- |
| select_type | JOIN, サブクエリを使用した時、どのテーブルにどういう順番でクエリが実行されるかを示す。tableカラムと合わせて見る。単一テーブルしか使わない場合は気にする必要はない |
| type | 対象テーブルに対してどのようにアクセスしたかを示す。特に注意すべきは以下の2つ<br /> index: フルインデックススキャン。インデックス全体をスキャンしているため遅い<br /> ALL: フルテーブルスキャン。インデックスが使用されていない状態 |
| key | どのインデックスが使用されたかを示す |
| rows | 対象テーブルからフェッチする行数の目安。インデックスが適切に使われいてもrowsが多すぎる場合、結果的に遅いクエリとなってしまう可能性がある。そのような場合はテーブル分割などを検討する |
| Extra | クエリ結果のソートが行われたか、実行にテンポラリテーブルが必要かどうかなど…様々な追加情報が出力される。以下によく問題になるであろう出力の一例を示す<br /> Using filesort: ORDER BY句などでクエリ結果をソートする必要がある場合に出力される。必要なソートがインデックスで行われていれば解決出来る<br /> Using tenporary: JOINの結果をソートする場合など、クエリ実行にテンポラリテーブルが必要となる場合に出力される。WHEREの検索条件とソート対象のカラムを1つのテーブルに集中させるなどで解決出来る |

* 注意点
  * 正確な実行計画を得るためにはプロダクションで使われている実際のデータで行う必要がある
  * テーブルの行数やインデックスの分散の仕方によって実行計画が変わる可能性があるからである

#### インデックスを使うためのクエリ

これまでインデックスにどういう特徴があるかという点について見てきた。インデックスはBツリー構造となっており、検索順序やソートの仕組み上、クエリの書き方によっては意図したインデックスが使われない可能性がある。

* 範囲条件が複数ある
  * 複数のカラムに対して範囲検索した場合、インデックスで取ってこれるのはいずれかのカラムに限られる
  * 範囲検索するカラムを一つにし、他を等値条件にすることで解決出来る。範囲条件を複数の等値条件にするので、IN句で書き換える事ができる

範囲条件をIN句に書き換える例

```
mysql> show index from follow;
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table  | Non_unique | Key_name                   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| follow |          0 | PRIMARY                    |            1 | user_id     | A         |        1988 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          0 | PRIMARY                    |            2 | follow_id   | A         |      507104 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            1 | user_id     | A         |        1996 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            2 | created_at  | A         |        1766 |     NULL | NULL   |      | BTREE      |         |               |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.00 sec)

mysql> select count(user_id) from follow where user_id < 5 and follow_id < 20;
+----------------+
| count(user_id) |
+----------------+
|             22 |
+----------------+
1 row in set (0.00 sec)

# SELECTで実際にフェッチする行数よりも多いrows(588)が検索されてしまっている
mysql> explain select count(user_id) from follow where user_id < 5 and follow_id < 20;
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
| id | select_type | table  | type  | possible_keys                      | key     | key_len | ref  | rows | Extra                    |
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
|  1 | SIMPLE      | follow | range | PRIMARY,idx_user_id_and_created_at | PRIMARY | 4       | NULL |  588 | Using where; Using index |
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
1 row in set (0.00 sec)

# 実際にフェッチする行数とrowsがほぼイコールになっている(rowsは見積もりなので実際のクエリ結果と一致しないことがある)
mysql> explain select count(user_id) from follow where user_id in (1,2,3,4) and follow_id < 20;
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
| id | select_type | table  | type  | possible_keys                      | key     | key_len | ref  | rows | Extra                    |
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
|  1 | SIMPLE      | follow | range | PRIMARY,idx_user_id_and_created_at | PRIMARY | 8       | NULL |   21 | Using where; Using index |
+----+-------------+--------+-------+------------------------------------+---------+---------+------+------+--------------------------+
1 row in set (0.01 sec)
```

* 強制的に任意のインデックスを使う
  * 実行計画上、必ず意図するインデックスが使われるとは限らない
  * `FORCE INDEX`を使うことによって任意のインデックスを強制的に使わせることが出来る

任意のインデックスを使う例

```
mysql> show index from follow;
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table  | Non_unique | Key_name                   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| follow |          0 | PRIMARY                    |            1 | user_id     | A         |        1988 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          0 | PRIMARY                    |            2 | follow_id   | A         |      507104 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            1 | user_id     | A         |        1996 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            2 | created_at  | A         |        1766 |     NULL | NULL   |      | BTREE      |         |               |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.00 sec)

# 通常であればidx_user_id_and_created_atが使われる
mysql> explain select * from follow where user_id=100 order by created_at;
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
| id | select_type | table  | type | possible_keys                      | key                        | key_len | ref   | rows | Extra       |
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
|  1 | SIMPLE      | follow | ref  | PRIMARY,idx_user_id_and_created_at | idx_user_id_and_created_at | 4       | const |  623 | Using where |
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
1 row in set (0.00 sec)

# 意図的にPRIMARYを指定した状態。keyがPRIMARYとなっている
mysql> explain select * from follow force index (PRIMARY) where user_id=100 order by created_at;
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra                       |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
|  1 | SIMPLE      | follow | ref  | PRIMARY       | PRIMARY | 4       | const |  623 | Using where; Using filesort |
+----+-------------+--------+------+---------------+---------+---------+-------+------+-----------------------------+
1 row in set (0.00 sec)
```

* インデックスとクエリの検索順序が合っていない
  * 複合インデックスを使用する場合、インデックスは1番目の列でソートされて2番目の列でソートされて…という形になっている
  * クエリの指定順がそれと直行する場合は上手くインデックスを使えない場合がある

インデックスとクエリの順序が合っていない例

```
# idx_user_id_and_created_at, idx_created_at_and_user_idの2つのインデックスを用意している
mysql> show index from follow;
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table  | Non_unique | Key_name                   | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| follow |          0 | PRIMARY                    |            1 | user_id     | A         |        1988 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          0 | PRIMARY                    |            2 | follow_id   | A         |      507104 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            1 | user_id     | A         |        1996 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_user_id_and_created_at |            2 | created_at  | A         |        1766 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_created_at_and_user_id |            1 | created_at  | A         |          32 |     NULL | NULL   |      | BTREE      |         |               |
| follow |          1 | idx_created_at_and_user_id |            2 | user_id     | A         |        1766 |     NULL | NULL   |      | BTREE      |         |               |
+--------+------------+----------------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
6 rows in set (0.00 sec)

# where user_id=100, order by created_atの順に評価され、インデックスも適切に振られているため、type=refで検索出来ている
mysql> explain select * from follow where user_id=100 order by created_at desc;
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
| id | select_type | table  | type | possible_keys                      | key                        | key_len | ref   | rows | Extra       |
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
|  1 | SIMPLE      | follow | ref  | PRIMARY,idx_user_id_and_created_at | idx_user_id_and_created_at | 4       | const |  623 | Using where |
+----+-------------+--------+------+------------------------------------+----------------------------+---------+-------+------+-------------+
1 row in set (0.00 sec)

# 意図的にidx_created_at_and_user_idを使用した場合。type=indexとなりフルインデックスキャンとなってしまっている
mysql> explain select * from follow force index (idx_created_at_and_user_id) where user_id=100 order by created_at desc;
+----+-------------+--------+-------+---------------+----------------------------+---------+------+--------+-------------+
| id | select_type | table  | type  | possible_keys | key                        | key_len | ref  | rows   | Extra       |
+----+-------------+--------+-------+---------------+----------------------------+---------+------+--------+-------------+
|  1 | SIMPLE      | follow | index | NULL          | idx_created_at_and_user_id | 9       | NULL | 507104 | Using where |
+----+-------------+--------+-------+---------------+----------------------------+---------+------+--------+-------------+
1 row in set (0.00 sec)
```

## 4. パーティション

パーティションはレコードを特定条件で振り分け、格納するテーブルを分割出来る機能である。振り分け条件によってRange, List, Hash, Keyパーティションが存在する。

#### パーティションの特徴

* パフォーマンス影響
  * インデックス、クエリを最適化していたとしても、定常的にデータ量が増えるテーブルへのクエリは徐々に遅くなってしまう
  * パーティションによってテーブル内のデータ量を減らすことが出来るので、結果的にクエリで扱うデータ量が少なくなりパフォーマンスが向上する
* MySQL側でどのパーティションに対して処理を実行するか判別してくれるため、既存クエリの書き換えが不要
* データ削除
  * 通常レコード削除に用いられるDELETEは特定レコードの検索、インデックスの削除が必要となるため遅い
  * パーティション単位で削除する場合、DROP PARTITIONで高速にデータ削除が可能になる
    * 例えば時系列データを扱うようなテーブルにおいて、n年前のデータを削除したいといった場合、Rangeパーティションで年単位で分割しておくなど

#### パーティションの構築

ここでは最もよく用いられるであろうRangeパーティションについて記述する。

* テーブル構造

```
mysql> desc user;
+--------------+--------------+------+-----+----------+----------------+
| Field        | Type         | Null | Key | Default  | Extra          |
+--------------+--------------+------+-----+----------+----------------+
| id           | int(11)      | NO   | PRI | NULL     | auto_increment |
| user_id      | int(11)      | NO   |     | NULL     |                |
| created_at   | datetime     | NO   | PRI | NULL     |                |
| updated_at   | datetime     | YES  |     | NULL     |                |
+--------------+--------------+------+-----+----------+----------------+
```

* 日単位でパーティションを分ける

```
# created_atに基づいて日単位で分割
ALTER TABLE user
PARTITION BY RANGE (TO_DAYS(created_at)) (
PARTITION p20160301 VALUES LESS THAN (TO_DAYS('2016-03-02 00:00:00')),
PARTITION p20160302 VALUES LESS THAN (TO_DAYS('2016-03-03 00:00:00')),
PARTITION p20160303 VALUES LESS THAN (TO_DAYS('2016-03-04 00:00:00')),
PARTITION p20160304 VALUES LESS THAN (TO_DAYS('2016-03-05 00:00:00'))
);
```

* 注意点
  * この状態で3/6以降のデータを入れようとすると対応するパーティションがないため、エラーとなってしまう
  * パーティション追加時にはロックがかかってしまうので、テーブル構築時点で数年分のパーティションを確保するなど、サービスの寿命に合わせて余裕を持って設定しておくのが良い

## 5. シャーディング

パーティション同様、レコードを何らかの条件で異なるテーブルに分割する手法である。パーティションより更に分割を推し進め、DB自体を分割し、それぞれにテーブルが格納される。

#### シャーディングの特徴

* パーティション同様、1テーブルあたりのデータ量が少なくなることによってパフォーマンス向上に寄与する
* パーティションのようにMySQLの構文レベルでサポートされている手法ではないため、アプリケーション側で実装されることが多い
  * 例えばDBを2つ用意しておき、`id`列のハッシュ値で分割したいといった場合、アプリケーション側でクエリを解析してクエリを投げるDB(テーブル)を決定するといった形である
* サーバ自体を分割出来るため、書き込み負荷を分散出来ることが出来る

## 6. サーバ設定

MySQLサーバ自体の設定を最適化することでパフォーマンスを上げる事もできる。ほとんどの設定値は十分に検証されているデフォルト値で良いが、一部サーバスペックに合わせて調整したほうが良いものがある。以下に特に重要なものについて言及する。

* innodb_buffer_pool_size
  * インデックス、行データ、挿入バッファ、ロックなどのキャッシュに利用する
  * またディスクへの書き込み遅延にも用いられ、複数の書き込みをマージしてシーケンシャルに実行することが出来る
  * 可能であれば搭載メモリの70〜80%を割り当てておく
    * あまりに大量のバッファを取るとOSやその他モジュールで必要なメモリサイズが足りなくなり、swapなどのより深刻な状況に陥るため余裕は持たせておく
* innodb_log_file_size
  * 更新が行われた際、実際にテーブルを更新する前に更新をためておくためのバッファである
  * ログファイルサイズを大きくするとそれだけテーブルを更新する頻度が軽減されるが、同時にクラッシュリカバリ処理が長時間化するというデメリットもある
    * クラッシュリカバリはMySQL5.5以降で改善されたため、現状それほど問題にはなっていない
  * 書き込みが高負荷である場合は数百MB〜数GBのサイズにしておくのが良い

設定ファイルサンプル

```
# メモリ64GBのサーバを想定
innodb_buffer_pool_size=50G
innodb_log_file_size=2G
```

## 参考

* https://www.oreilly.co.jp/books/9784873116389/
* https://dev.mysql.com/doc/refman/5.6/ja/optimization-indexes.html
* http://www.mysql.gr.jp/frame/modules/bwiki/index.php?plugin=attach&refer=matsunobu&openfile=Session-Index.pdf
