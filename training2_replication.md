## 1. パフォーマンス観点

単純にパフォーマンスと言った場合の捉え方は人様々である。
例えば以下のような項目が考えられる。

* 1秒あたりのクエリ数
* CPU使用率
* スケーラビリティ

前提としてここではパフォーマンスは `1クエリあたりの応答時間` を指標とする。
データベースサーバとして最も興味があるであろう、クエリを解釈してデータを返すというタスクのパフォーマンスを見るのに適当だからである。

また特に断りのない限り、本内容はInnoDBを想定したものとする。

## 2. プロファイリング

何をチューニングすべきか、チューニングした結果どう変わったか、その指標とするためにプロファイリングを用いる。

### 2.1. スロークエリログ

クエリにどのくらい時間がかかったかなどの情報を出力するためのログ。後述するプロファイリングツールはこのログを解析して結果を出しているものが多い。

#### 主要な設定項目

* `slow_query_log`
  * スロークエリログを出力するかどうか
* `long_query_time`
  * スロークエリログに出力するための閾値とする実行時間
  * 0 を設定することで全クエリが出力される
  * 0.5秒以上かかったクエリを出力したいのであれば `0.5` と指定する
* `log_queries_not_using_indexes`
  * インデックスが使われていないクエリを出力するかどうか
  * 有効化すると `long_query_time` に該当しないクエリでも出力されるようになる
* `slow_query_log_file`
  * スロークエリログの出力先
  * デフォルトでは `datadir/<hostname>-slow.log` に出力される
* `log_slow_admin_statements`
  * 管理ステートメントのログ出力を行うかどうか
  * 対象のステートメント
    * ALTER TABLE
    * ANALYZE TABLE
    * CHECK TABLE
    * CREATE INDEX
    * DROP INDEX
    * OPTIMIZE TABLE
    * REPAIR TABLE

#### 設定ファイルサンプル

```
# スロークエリログを出力する
slow_query_log=1

# ログを出す閾値を1秒にする
# ※ 1秒未満のクエリが大量にあり、それで全体的に遅くなっている場合には対応出来ない。その場合はmysqlコンソールから閾値を一時的に0にするなどして対応する
long_query_time=1

# インデックスが使われていないクエリは特別出力しない
log_queries_not_using_indexes=0

# ログファイルは `/var/log/` に集めておく
slow_query_log_file=/var/log/mysql/slow.log

# 管理ステートメントは出力しない
# 管理ステートメントは多くの場合人間が主体となって行うので無視しておく
log_slow_admin_statements=0
```

### 2.2. スロークエリログの解析

スロークエリログ単体ではログの量が膨大になるため、通常ログと合わせて解析ツールが用いられる。

#### mysqldumpslow

* 特徴
  * 公式の解析ツール
  * mysqlに付属している
  * 以下いずれかの項目でソートした結果を出力出来る
    * 総ロックタイム
    * 総行数
    * 総実行時間
    * 総クエリ数
    * 平均ロックタイム
    * 平均行数
    * 平均実行時間(デフォルト)

実行例

```
# 総実行時間が長い順でソート
$ mysqldumpslow -s t slow_query.log
```

#### pt-query-digest

* 特徴
  * Percona Serverを作っているPercona社が作っている
  * スロークエリログ以外にも `PROCESSLIST` や `tcpdump` のデータを元に解析が可能
  * 総実行時間、総クエリ数などいくつかの軸でクエリをランキングしてくれる
  * 解析と同時に各クエリのサマリの `explain` 結果が出力可能

* インストール

RHEL系

```
yum install perl-Time-HiRes perl-IO-Socket-SSL
yum localinstall http://www.percona.com/redir/downloads/percona-toolkit/LATEST/RPM/percona-toolkit-2.2.7-1.noarch.rpm
```

実行例

```
# スロークエリログから読む
$ pt-query-digest --type slowlog slow.log

# processlistから読む
$ pt-query-digest --processlist h=localhost,u=root,p=password --run-time 60

# tcpdumpから読む
$ tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 mysql.tcpdump
$ pt-query-digest --type tcpdump mysql.tcpdump
```

* todo: どういう観点で見ていくかを書く
  * まず総実行時間を見て、総クエリ数、ロック数を見ていくなど

## 3. インデックス

* 前提はInnoDBとする
  * インデックスはB+Tree構造を使っているものとする
* どういう場合に有効か
  * 多くの場合で有効。とりあえずやっていない場合はやって良い
  * インデックスを貼っても検索行数が大きすぎる場合は効果が薄い
    * パーティション、シャーディングでテーブルを分割させて母数のデータ数を減らす
    * 巨大なユーザテーブルを分解して、特定のグループだけが集まるようなユーザテーブルを抽出するなど
(* インデックスの構造
  * インデックスの持ち方
  * クラスタインデックス
  * セカンダリインデックス)
* カーディナリティ
* 複合インデックスの順番
  * カーディナリティも考慮して最初からとか
( * 実際にインデックスを使うときのコーナーケース
  * プレフィックスインデックス
    * BLOB型やTEXT型などの非常に大きいデータを持つカラムにインデックスを貼りたい場合
    * InnoDBはインデックスをキーとするので余計にディスクを食う。そもそも付けれるインデックス名に制限長がある)
* explain
* インデックスを使うためのクエリの書き方
  * 範囲指定とか
  * 順序の話
  * 最終手段としてforce index
* 講師側で準備したindexチューニング前後のexplain結果(サンプルファイル)を見せる

インデックスはデータファイル上の特定行におけるポインタの様なものである。もしインデックスが無ければ、クエリで該当行を見つけるためにデータファイルを先頭行から始めてテーブル全体を読み取る必要がある。

#### インデックスの構造

* Bツリー
  * InnoDBのインデックスはBツリーで管理される
  * 検索時の計算量が小さくなるような構造
  * ノード1つにつきブロック1つと紐付けられる
    * HDDはブロック間のシーク時間がボトルネックとなるので特に有効
    * SSDも結局ブロックデバイスなので依然重要
* クラスタインデックス
  * 全てのテーブルに必ず存在する特別なインデックス
  * ノードのキーは以下のいずれかになる。ほとんどの場合は主キーが選択される
    * 1. 主キー
    * 2. NOT NULLかつUNIQUEなカラム
    * 1, 2に該当しない場合、暗黙的に行IDが振られたキーが生成され利用される
  * リーフノードにはレコードのデータ全てが保存される
    * データ自体がノードに格納されるため、検索とデータのフェッチが同時に行われる
* セカンダリインデックス
  * `create index` 文で作られるいわゆるインデックス
  * ノードのキーにはインデックス名がそのまま利用される
  * リーフノードにはクラスタインデックスのキーが格納される
    * つまりデータを取るためにはセカンダリインデックス→クラスタインデックスのアクセスが必要となる
    * ただし必要なデータがセカンダリインデックスのキーで事足りていればクラスタインデックスへのアクセスは不要となる
      * カバリングインデックスと呼ばれる

#### インデックス利用の仕方

* カーディナリティ
  * 全レコードに対して、インデックスを使用して絞り込める件数の割合
  * 絞り込める件数が少ないほどカーディナリティが高い状態である
  * 例
    * 性別: 一般的に性別は二種類に分類されるため、インデックスを貼っても効果は少ない
    * 住所: 都道府県、もしくは市町村単位で絞り込めるため、インデックスを貼った時の効果は大きい
* 複合インデックス
  * MySQLでは原則1クエリで使用出来るインデックスは1つだけである
  * 1インデックスとは以下の単位でカウントされる
    * todo:

#### インデックス利用の調査

* explain
  * クエリで使用されるインデックス、ファイルソートの有無などを調べる事ができる
* 注意点
  * 正確な実行計画を得るためにはプロダクションと同一のデータで行う必要がある

#### インデックスを使うためのクエリ

* 範囲指定
* 順序
* force index(最終手段)

#### インデックス設定前後のサンプル

## 4. パーティション

* 母数を減らすために有効
* 設定方法

## 5. シャーディング

* 母数を減らすために有効
* Updateの負荷が分散出来る
* 設定方法
  * キーの振り分け方式など
    * ユーザID % 100 が計算しやすくて運用にも便利だよという結論

## 6. サーバ設定

* メモリに載せたほうが良い

## 7. Tips

* パフォーマンス上げるための考え方
  * インデックス, クエリ
  * ハードウェア
  * 最後の手段としてパーティション、シャーディングとか

## 参考メモ

http://naokirin.hatenablog.com/entry/2015/02/07/193609
http://www.mysql.gr.jp/frame/modules/bwiki/index.php?plugin=attach&refer=matsunobu&openfile=Session-Index.pdf
